Problem: Two-Sum with Doubles

Description:
Given an array of integers nums and an integer target, return all unique pairs of indices (i, j) such that:
* nums[i] + nums[j] == target
* i ≠ j (different indices)
* Each pair (i, j) is counted only once (no duplicates like (1,3) and (3,1))
* If a number appears twice and satisfies the condition (e.g., nums[i] * 2 == target), include the pair (i, j) where i and j are the two distinct indices of that number.

Key twist: Unlike classic Two-Sum, we return all valid pairs, not just one.

Input:
* nums: List of integers (length ≥ 2)
* target: Integer

Output:
- List of tuples (i, j) where:
 * i < j (to avoid duplicates like (3,1) and (1,3))
 * nums[i] + nums[j] == target
 * All pairs are unique by index

Requirements:
1. No duplicate index pairs: Return (i,j) only if i < j.
2. Handle duplicates in input: If nums has two 5s at indices 2 and 4, and target == 10, include (2,4).
3. Efficiency: Use hash map for O(n) average case.
4. Edge cases:
 * Empty list → []
 * No valid pairs → []
 * Multiple pairs possible → return all

Algorithm Hints:
1. Use a dictionary to store all indices of each number (since duplicates exist).
2. For each num in nums:
 - Compute complement = target - num
 - If complement exists in the map:
  * For each index i of num and index j of complement where i < j, add (i,j)
3. Avoid double-counting by ensuring i < j.

Examples
Example 1: Basic Case
nums = [2, 7, 11, 15], target = 9
→ Output: [(0, 1)]
# Explanation: 2 + 7 = 9 (indices 0 and 1)

Example 2: Duplicate Values Forming Valid Pair
nums = [3, 2, 4, 3], target = 6
→ Output: [(0, 3), (1, 2)]
# Explanation:
# - 3 (index 0) + 3 (index 3) = 6 → (0, 3)
# - 2 (index 1) + 4 (index 2) = 6 → (1, 2)

Example 3: Exact Double (Same Number at Different Indices)
nums = [5, 1, 5, 3], target = 10
→ Output: [(0, 2)]
# Explanation: 5 (index 0) + 5 (index 2) = 10 → (0, 2)

Example 4: Multiple Valid Pairs with Different Numbers
nums = [1, 2, 3, 4, 5], target = 5
→ Output: [(0, 3), (1, 2)]
# Explanation:
# - 1 (index 0) + 4 (index 3) = 5 → (0, 3)
# - 2 (index 1) + 3 (index 2) = 5 → (1, 2)

Example 5: No Valid Pairs
nums = [1, 2, 3], target = 10
→ Output: []
# Explanation: No two numbers sum to 10

Example 6: Empty Input
nums = [], target = 5
→ Output: []
# Explanation: Empty list → no pairs possible

Example 7: Single Element (Invalid)
nums = [1], target = 2
→ Output: []
# Explanation: Only one element → no pair possible

Example 8: Negative Numbers
nums = [-2, -1, 0, 1], target = -1
→ Output: [(0, 1), (0, 3)]
# Explanation:
# - (-2) (index 0) + (-1) (index 1) = -3 → ❌
# - (-2) (index 0) + 1 (index 3) = -1 → (0, 3) ✅
# - (-1) (index 1) + 0 (index 2) = -1 → (1, 2) ✅
# Final: [(0, 3), (1, 2)] → sorted → [(0, 3), (1, 2)]

Example 9: Target is Zero with Negative and Positive Numbers
nums = [-3, 1, 2, 3], target = 0
→ Output: [(0, 3)]
# Explanation: (-3) (index 0) + 3 (index 3) = 0 → (0, 3)

Example 10: All Elements Are the Same
nums = [4, 4, 4, 4], target = 8
→ Output: [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]
# Explanation: Every pair of indices (i < j) sums to 8

Example 11: Large Numbers
nums = [1000000000, -1000000000, 500000000], target = 0
→ Output: [(0, 1)]
# Explanation: 1e9 + (-1e9) = 0 → (0, 1)

Example 12: Target Larger Than All Elements
nums = [1, 2, 3], target = 100
→ Output: []
# Explanation: Sum of any two elements < 100

Constraints:
* 2 ≤ len(nums) ≤ 10⁴
* -10⁹ ≤ nums[i], target ≤ 10⁹
* All inputs are integers