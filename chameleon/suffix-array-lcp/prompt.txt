Use Python to solve this problem.

Problem: Suffix Array with Longest Common Prefix

Description:
Given a string S, compute its suffix array and the longest common prefix (LCP) array.
Then answer Q queries of the form:
- "LCP i j": Find the length of the longest common prefix between the i-th and j-th suffixes in the suffix array
- "KTH k": Find the k-th lexicographically smallest distinct substring

Input:
- First line: S (the input string)
- Second line: Q (number of queries)
- Next Q lines: queries in the formats above

Output:
- For each "LCP i j" query, output the LCP length
- For each "KTH k" query, output the k-th smallest distinct substring

Constraints:
- 1 ≤ |S| ≤ 100,000
- 1 ≤ Q ≤ 100,000
- String contains only lowercase English letters
- For LCP queries: 0 ≤ i, j < |S|
- For KTH queries: 1 ≤ k ≤ total number of distinct substrings

Example 1:
Input:
banana
5
LCP 0 1
LCP 1 2
KTH 1
KTH 5
KTH 10

Output:
1
3
a
anana
banan

Example 2:
Input:
abab
4
LCP 0 1
LCP 1 2
KTH 3
KTH 6

Output:
2
0
aba
ba

Explanation:
Suffix Array for "abab": [2, 0, 3, 1] representing:
0: "ab" (starting at index 2)
1: "abab" (starting at index 0)
2: "b" (starting at index 3)
3: "bab" (starting at index 1)

LCP array: [0, 2, 0, 1]

LCP(0,1): between "ab" and "abab" = 2
LCP(1,2): between "abab" and "b" = 0

Distinct substrings in lex order:
1: "a"
2: "ab"
3: "aba"
4: "abab"
5: "b"
6: "ba"
7: "bab"

KTH 3: "aba", KTH 6: "ba"

Implementation Approach:
1. Build suffix array using doubling method
2. Build LCP array using Kasai's algorithm
3. For KTH queries, use the fact that number of distinct substrings = total substrings - sum(LCP)
4. Binary search to find the k-th distinct substring