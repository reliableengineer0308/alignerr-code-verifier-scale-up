
Use Python to solve this problem.

Problem: Sliding Window Mode

Description:
You are an expert Python programmer. You should provide a Python function `sliding_window_mode(nums, k)` or a class `SlidingWindowMode` with method `find_mode_in_window(nums, k)` for the problem below.

You are given an integer array `nums` and a window size `k`. Your task is to compute the **mode** (most frequent element) for every contiguous sliding window of size `k` across `nums`.

When multiple elements share the highest frequency in a window, return the **numerically smallest** among them.

Input:
- An integer array `nums` where `3 ≤ len(nums) ≤ 10⁵`
- An integer `k` where `1 ≤ k ≤ len(nums)`
- Each element satisfies `-10⁵ ≤ nums[i] ≤ 10⁵`


Output:
- Return a list of integers: the mode of each sliding window from left to right
- If `k == 1`, return each element (as each is its own mode)
- The result must have length `len(nums) - k + 1`


Example 1:
Function: sliding_window_mode(nums, k)
Input: nums = [4, 1, 1, 3, 3, 3], k = 3
Output: [1, 1, 3, 3]
Explanation:
- Window [4,1,1]: freq = {4:1, 1:2} → mode = 1
- Window [1,1,3]: freq = {1:2, 3:1} → mode = 1
- Window [1,3,3]: freq = {1:1, 3:2} → mode = 3
- Window [3,3,3]: freq = {3:3} → mode = 3


Example 2:
Function: sliding_window_mode(nums, k)
Input: nums = [2, 2, 1], k = 2
Output: [2, 1]
Explanation:
- Window [2,2]: freq = {2:2} → mode = 2
- Window [2,1]: freq = {2:1, 1:1} → tie → min(2,1) = 1


Example 3:
Function: sliding_window_mode(nums, k)
Input: nums = [-1, -1, -2, -2, -3], k = 3
Output: [-1, -2, -2]
Explanation:
- [-1,-1,-2]: freq = {-1:2} → mode = -1
- [-1,-2,-2]: freq = {-2:2} → mode = -2
- [-2,-2,-3]: freq = {-2:2} → mode = -2

Example 4:
Function: sliding_window_mode(nums, k)
Input: nums = [7, 7, 7], k = 2
Output: [7, 7]
Explanation: All windows contain only 7s → mode = 7


Example 5:
Function: sliding_window_mode(nums, k)
Input: nums = [5], k = 1
Output: [5]


Constraints:
- 1 ≤ k ≤ len(nums) ≤ 10⁵
- -10⁵ ≤ nums[i] ≤ 10⁵ for all valid i
- Division or floating-point operations are NOT required
- c (denominator) is NOT involved — this is a frequency-based mode problem
- Elements must be from contiguous subarrays of length k
- You must avoid O(n × k) brute-force counting
- Aim for O(n) time and O(k) space complexity
- Handle edge cases: k=1, k=len(nums), all same, all unique, negatives
- Return the smallest element when frequencies tie


Your Task:
Implement the solution with one of these interfaces:


Option A: Function-based
def sliding_window_mode(nums: List[int], k: int) -> List[int]:
    # Your code here

Option B: Class-based
class SlidingWindowMode:
    def find_mode_in_window(self, nums: List[int], k: int) -> List[int]:
        # Your code here

Key Requirements:
1. Use efficient frequency tracking (e.g., hash maps)
2. Maintain current max frequency to avoid scanning all elements
3. Resolve ties by selecting min(element) among those with max frequency
4. Support negative numbers and zero
5. Handle window slides by adding/removing elements incrementally
6. Do not recalculate frequencies from scratch for each window
7. Ensure O(n) time and O(k) space

Hints:
- Use freq: dict[int, int] to track count of each element in current window
- Use freq_count: dict[int, set[int]] to map frequencies to elements with that count
- Track max_freq to know highest frequency instantly
- When removing an element, update freq and freq_count, then lazily decrement max_freq if its group becomes empty
- For ties: mode = min(freq_count[max_freq])

Slide window by removing leftmost, adding rightmost

Testing Notes:
- Test k=1 and k=len(nums)
- Test all identical elements
- Test all unique elements
- Test negative numbers
- Test frequent ties requiring min-selection
- Test large inputs (~10⁵ elements)