Problem: Segment Tree Updates Optimization

Description:
Implement a Segment Tree with efficient range updates and point/range queries. The tree should support:
* Range updates (add a value to all elements in [l, r])
* Point queries (get value at index i)
* Range sum queries (sum over [l, r])
Optimized using lazy propagation to avoid O(n) updates.

Input:
- Initial array arr of n integers
- Series of operations:
 * update(l, r, val): Add val to all elements from index l to r (inclusive)
 * query_point(i): Return value at index i
 * query_range(l, r): Return sum of elements from l to r

Output:
* Results of all query_point and query_range operations

Requirements:
1. Use Segment Tree with Lazy Propagation for O(log n) updates and queries.
2. Support 0-based indexing.
3. Handle edge cases:
 * Empty array → return 0 for queries
 * Invalid ranges (l > r) → return 0
4. Memory: O(4n) for tree and lazy arrays

Algorithm Hints:
1. Build a segment tree where each node stores:
 * Sum of its range
 * Lazy value (pending updates)
2. For update(l, r, val):
 * Traverse tree, apply lazy propagation when needed
 * Update nodes covering [l, r], store pending updates in lazy
3. For query_*:
 * Propagate pending updates before accessing values

Key Operations:
* build(): O(n)
* update(): O(log n)
* query_point(): O(log n)
* query_range(): O(log n)

Examples:
arr = [1, 3, 5, 7, 9, 11]
st = SegmentTree(arr)
st.update(1, 3, 2)  # [1,5,7,9,9,11]
st.query_point(2)       # → 7
st.query_range(0, 4)  # → 1+5+7+9+9 = 31

arr = [0, 0, 0]
st = SegmentTree(arr)
st.update(0, 2, 5)  # [5,5,5]
st.query_range(1, 2)   # → 10

Constraints:
* 1 ≤ n ≤ 10⁵
* -10⁹ ≤ arr[i], val ≤ 10⁹
* Number of operations ≤ 10⁴

Note: Implement with 1-based tree indexing internally for easier child calculations.