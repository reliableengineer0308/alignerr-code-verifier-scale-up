Problem: Efficient Rotation of a Square Matrix

Description:
Given an n × n 2D matrix, rotate it 90 degrees clockwise in-place (without allocating another 2D matrix).

Goal: Modify the input matrix so that it represents the 90-degree clockwise rotation.

Input:
* matrix: List[List[int]] — square matrix of integers
* 1≤n≤500
* −10^6≤matrix[i][j]≤10^6

Output:
* None (modify the matrix in-place)

Examples:
1. Input:
1 2 3
4 5 6
7 8 9
→ Output:
7 4 1
8 5 2
9 6 3

2. Input:
 5  1  9 11
 2  4  8 10
13  3  6  7
15 14 12 16
→ Output:
15 13  2  5
14  3  4  1
12  6  8  9
16  7 10 11

Algorithm Requirements:
Implement in-place rotation using one of these approaches:
Option 1: Transpose + Reverse Rows
1. Compute the transpose of the matrix (swap matrix[i][j] with matrix[j][i])
2. Reverse each row of the transposed matrix
Option 2: Cyclic Rotation (Layer-by-Layer)
1. Process the matrix in concentric layers (from outer to inner)
2. For each layer, rotate elements in groups of 4 (top → right → bottom → left)
3. Use temporary variable to store one element during swap

Recommended Approach: Transpose + Reverse (simpler, fewer edge cases)
Steps (Transpose + Reverse):
1. Transpose the matrix:
 * For i in 0 to n-1
 * For j in i+1 to n-1
 * Swap matrix[i][j] with matrix[j][i]
2. Reverse each row:
 * For each row i, reverse matrix[i] using two pointers

Why this works:
* Transpose converts rows to columns
* Reversing rows after transpose gives 90° clockwise rotation

Edge Cases:
* 1×1 matrix (no change)
* 2×2 matrix
* Even vs odd n

Complexity:
* Time: O(n^2) — visit each element once
* Space: O(1) — in-place modification

Constraints:
* Do NOT return a new matrix
* Must modify matrix directly