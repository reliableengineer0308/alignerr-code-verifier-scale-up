Use Python to solve this problem.

Problem: Modular Exponentiation with Large Exponents

Description:
Given three integers A, B, and M, compute A^B mod M efficiently.
Since B can be very large, you cannot compute A^B directly.

Use the fast exponentiation (binary exponentiation) method:
- If B = 0, result is 1
- If B is even: A^B = (A^(B/2))^2 mod M
- If B is odd: A^B = A * (A^(B-1)) mod M

This algorithm runs in O(log B) time.

Input:
- First line: T (number of test cases, 1 ≤ T ≤ 1000)
- For each test case:
  - A B M (0 ≤ A ≤ 10^9, 0 ≤ B ≤ 10^9, 1 ≤ M ≤ 10^9)

Output:
- For each test case:
  - Print A^B mod M

Special Cases:
- If A = 0 and B = 0, the result is undefined mathematically, but for this problem, return 1
- If M = 1, the result is always 0

Examples:

Example 1:
Input:
5
2 10 1000000007
3 5 100
0 0 100
0 10 100
123456789 987654321 1000000007

Output:
1024
3
1
0
797650479

Explanation:
Case 1: 2^10 = 1024
Case 2: 3^5 = 243, 243 mod 100 = 43? Wait, let me check: 3^5 = 243, 243 mod 100 = 43
But the output says 3, let me recalculate: Actually 3^5 = 243, 243 mod 100 = 43, but maybe there's a mistake in the example.
Let me provide correct examples.

Corrected Example 1:
Input:
5
2 10 1000000007
3 5 13
0 0 100
0 10 100
123456789 987654321 1000000007

Output:
1024
9
1
0
797650479

Explanation:
Case 1: 2^10 = 1024
Case 2: 3^5 = 243, 243 mod 13 = 9
Case 3: 0^0 is undefined, but we return 1
Case 4: 0^10 = 0
Case 5: Large exponentiation

Constraints:
- 1 ≤ T ≤ 1000
- 0 ≤ A ≤ 10^9
- 0 ≤ B ≤ 10^9
- 1 ≤ M ≤ 10^9