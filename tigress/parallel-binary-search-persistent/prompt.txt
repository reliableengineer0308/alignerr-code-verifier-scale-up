Use Python to solve this problem.

Problem: Parallel Binary Search with Persistent Segment Trees

Description:
You are given an array of N integers and M queries. Each query asks for the k-th smallest element in a specific range [L, R]. 
Instead of processing queries one by one, you need to use Parallel Binary Search (PBS) with Persistent Segment Trees to efficiently answer all queries.

The challenge is to handle large constraints where N and M can be up to 200,000.

Input:
- First line: N (array size)
- Second line: N integers (array elements, 0-indexed)
- Third line: M (number of queries)
- Next M lines: L R K (1-indexed range [L, R] and k for k-th smallest)

Output:
- For each query, output the k-th smallest element in range [L, R]

Constraints:
- 1 ≤ N ≤ 200,000
- 1 ≤ M ≤ 200,000  
- 1 ≤ L ≤ R ≤ N
- 1 ≤ K ≤ (R - L + 1)
- Array elements: -10^9 ≤ A[i] ≤ 10^9

Example 1 - Simple Case:
Input:
5
3 1 4 2 5
3
1 3 2
2 5 3
1 5 1

Output:
3
4
1

Example 2 - All Elements Same:
Input:
6
5 5 5 5 5 5
4
1 3 2
2 4 1
3 6 3
1 6 4

Output:
5
5
5
5

Example 3 - Large Range with Duplicates:
Input:
8
10 20 10 30 20 10 40 30
5
1 4 2
2 6 3
3 8 1
1 8 5
4 7 2

Output:
10
20
10
20
20

Algorithm Requirements:
- Implement Parallel Binary Search (also known as "offline binary search")
- Use Persistent Segment Trees for efficient range queries
- The solution should run in O((N + M) * log(N) * log(max_value)) time complexity
- Handle coordinate compression for large value ranges

Explanation for Beginners:
1. Parallel Binary Search processes all queries simultaneously through multiple binary search iterations
2. Persistent Segment Trees allow us to query any historical version of the segment tree
3. For k-th smallest in range, we binary search on the answer and count how many elements ≤ mid
4. Coordinate compression is needed when values are large but sparse

Implementation Steps:
1. Compress the array values to range [0, N-1]
2. Build persistent segment tree that stores count of elements
3. For PBS, maintain for each query: current search range [low, high]
4. In each iteration, compute mid = (low + high) // 2 for all queries
5. Use persistent segment tree to count elements ≤ mid in each query range
6. Update search ranges based on whether count >= k or not