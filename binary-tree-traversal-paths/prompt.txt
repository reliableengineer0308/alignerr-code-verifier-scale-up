Problem: Binary Tree Traversal Paths

Description:
Given the root of a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children. Each path should be represented as a string where node values are joined by "->".

Goal: Return a list of strings representing all root-to-leaf paths.

Input:
* root: TreeNode object (or None)
* TreeNode structure:
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
* Number of nodes: 1≤n≤100
* Node values: −100≤val≤100

Output:
* List[str]: all root-to-leaf paths as strings (e.g., "1->2->5")

Examples:
1. root = [1,2,3,None,5] → ["1->2->5", "1->3"]
Explanation: Two paths: 1→2→5 and 1→3
2. root = [1] → ["1"]
Explanation: Single node is a leaf
3. root = [2,1,3,None,4] → ["2->1->4", "2->3"]

Algorithm Requirements:
Implement using Depth-First Search (DFS) with backtracking:
1. Start from root, maintain current path as a list/string
2. At each node:
* Add current node value to path
* If it’s a leaf (no left/right children), add path to result
* Otherwise, recursively explore left and right subtrees
3. Backtrack: remove current node from path before returning

Approach Options:
Option 1: Recursive DFS with String Concatenation
 * Pass current path string to recursive calls
 * At leaf, append path to result list
 * Simple but creates new strings at each step
Option 2: Recursive DFS with List + Join
 * Use a list to collect node values during traversal
 * When reaching leaf, join list with "->" and add to result
 * More memory efficient for deep trees
Option 3: Iterative DFS with Stack
 * Use stack to store (node, path) pairs
 * Process nodes in LIFO order
 * Suitable for avoiding recursion depth limits

Recommended Approach: Recursive DFS with List
Steps:
1. Initialize empty result list
2. Define helper function dfs(node, path)
3. In helper:
 * Append node.val to path
 * If leaf: add "->".join(path) to result
 * Else: recurse on left/right children
 * Pop last value from path (backtrack)
4. Call dfs(root, [])
5. Return result

Edge Cases:
* Single node tree
* Skewed tree (all left/all right)
* Balanced tree

Complexity:
* Time: O(n) — visit each node once
* Space: O(h) — recursion depth = tree height h (plus output space)