Use Python to solve this problem.

Problem: Matrix Exponentiation for Linear Recurrence Relations

Description:
Given a linear recurrence relation of order k:
F(n) = a₁*F(n-1) + a₂*F(n-2) + ... + aₖ*F(n-k)

And initial values F(0), F(1), ..., F(k-1),
compute F(n) modulo M for very large n using matrix exponentiation.

Input:
- First line: T (number of test cases)
- For each test case:
  - First line: k n M
    - k: order of recurrence
    - n: term to compute
    - M: modulus
  - Second line: k coefficients a₁, a₂, ..., aₖ
  - Third line: k initial values F(0), F(1), ..., F(k-1)

Output:
- For each test case: F(n) mod M

Constraints:
- 1 ≤ T ≤ 100
- 1 ≤ k ≤ 10
- 0 ≤ n ≤ 10^18
- 1 ≤ M ≤ 10^9

Examples:

Example 1 (Fibonacci sequence):
Input:
1
2 10 1000
1 1
0 1

Output:
55

Explanation:
Fibonacci: F(n) = F(n-1) + F(n-2), F(0)=0, F(1)=1
F(10) = 55

Example 2:
Input:
1
3 5 100
2 1 1
1 1 2

Output:
11

Explanation:
Recurrence: F(n) = 2*F(n-1) + F(n-2) + F(n-3)
Initial: F(0)=1, F(1)=1, F(2)=2
Compute:
F(3) = 2*2 + 1 + 1 = 6
F(4) = 2*6 + 2 + 1 = 15
F(5) = 2*15 + 6 + 2 = 38 mod 100 = 38
Wait, let me recalculate with correct matrix exponentiation...

Actually, using matrix exponentiation:
[F(n)  ]   [a₁ a₂ aₖ]   [F(n-1)]
[F(n-1)] = [1  0  0 ] × [F(n-2)]
[ ...  ]   [0  1  0 ]   [ ...  ]

For this case:
[F(3)]   [2 1 1] [F(2)]   [2 1 1] [2]   [6]
[F(2)] = [1 0 0] [F(1)] = [1 0 0] [1] = [2]
[F(1)]   [0 1 0] [F(0)]   [0 1 0] [1]   [1]

[F(5)] = M^3 × [F(2), F(1), F(0)]^T
Where M = [[2,1,1],[1,0,0],[0,1,0]]
M^3 = [[11, 6, 3], [6, 3, 2], [3, 2, 1]]
[F(5)] = 11*2 + 6*1 + 3*1 = 22 + 6 + 3 = 31 mod 100 = 31
But the output says 11, so let me check the actual calculation...

After verification, the correct calculation gives:
F(0)=1, F(1)=1, F(2)=2
F(3)=2*2 + 1*1 + 1*1 = 4+1+1=6
F(4)=2*6 + 1*2 + 1*1 = 12+2+1=15
F(5)=2*15 + 1*6 + 1*2 = 30+6+2=38 mod 100 = 38

There seems to be inconsistency in the example. Let's use verified values.

Example 3 (Verified):
Input:
1
2 5 1000
1 1
0 1

Output:
5

Explanation:
Fibonacci: F(5) = 5

Implementation Requirements:
1. Use matrix exponentiation for O(k³ log n) complexity
2. Handle very large n (up to 10^18)
3. Apply modulus M correctly
4. Support recurrence orders up to 10