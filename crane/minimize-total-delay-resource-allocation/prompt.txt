Problem Title: Minimizing Total Delay in Resource Allocation

Problem Description
You are managing a system with m identical resources (e.g., servers, workers, machines) and must allocate them to n tasks. Each task i has:
* processing_time[i]: time required to complete if assigned to one resource
* dependencies[i]: list of tasks that must finish before task i can start
When a task is assigned to k resources simultaneously, its effective processing time becomes ceil(processing_time[i] / k).

Your goal: Minimize the total completion time (makespan) — the time when the last task finishes.

You must:
1. Assign resources to tasks (each resource can work on only one task at a time)
2. Respect dependencies
3. Schedule tasks optimally across time
Return the minimum possible makespan.

Key Requirements:
Input Constraints:
* 1 ≤ n ≤ 100 (number of tasks)
* 1 ≤ m ≤ 50 (number of resources)
* 1 ≤ processing_time[i] ≤ 1000
* Dependencies form a DAG (no cycles)
* Each task can use 1 to m resources simultaneously
2. Output: Integer — minimum makespan (time when all tasks complete)
3. Rules:
* Resources are preemptible: can switch tasks at any time
* A task using k resources runs in ceil(pt[i]/k) time
* No task can start until all its dependencies are fully completed
* Multiple tasks can run in parallel if resources allow
4. Objective: Minimize total time to finish all tasks

Examples:
Example 1:
n = 3, m = 2
processing_time = [4, 6, 8]
dependencies = [[], [0], [1]]  # Task 1 needs 0; Task 2 needs 1
→ Output: 9
Explanation:
- T0 runs on 2 resources → finishes at ceil(4/2)=2
- T1 starts at 2, uses 2 resources → ceil(6/2)=3 → finishes at 5
- T2 starts at 5, uses 2 resources → ceil(8/2)=4 → finishes at 9

Example 2:
n = 2, m = 3
processing_time = [10, 10]
dependencies = [[], []]
→ Output: 4
Explanation: Both tasks run in parallel.
- T0 uses 3 resources → ceil(10/3)=4
- T1 uses 3 resources → ceil(10/3)=4
→ All finish at 4

Example 3:
n = 4, m = 2
processing_time = [5, 3, 4, 7]
dependencies = [[], [], [0,1], [2]]
→ Output: 11
Explanation:
- T0 (5) and T1 (3) start at 0
- T0: ceil(5/1)=5 (use 1 resource), T1: ceil(3/1)=3 (use 1)
- T2 can start at max(5,3)=5, uses 2 → ceil(4/2)=2 → finishes 7
- T3 starts at 7, uses 2 → ceil(7/2)=4 → finishes 11

Solution Approach:
1. Topological Sort: Process tasks in dependency order
2. Dynamic Programming: Track earliest start time for each task
3. Resource Allocation Heuristic: For each task, try all possible resource assignments (1 to m)
4. Greedy Scheduling: Assign resources to minimize overlap and idle time
5. Binary Search on Makespan (optional optimization)