Problem Title: Merge Intervals

Description:
Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

Your task is to implement an efficient algorithm that merges overlapping intervals into a minimal set of non-overlapping ones.

Key Requirements:
* Sort intervals by start time to enable linear merging
* Iterate and merge if current interval overlaps with the last merged one
* Return a new list of merged intervals
* Handle edge cases (empty input, single interval, no overlaps)
* Optimize for O(n log n) time due to sorting, O(n) space for output

Input Format:
- intervals: List[List[int]] where:
 * 0 ≤ len(intervals) ≤ 10⁴
 * Each interval i satisfies 0 ≤ starti ≤ endi ≤ 10⁴

Output Format:
List[List[int]]: merged non-overlapping intervals sorted by start time

Examples:

Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: [1,3] and [2,6] overlap → merged into [1,6]

Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals are considered overlapping if they touch at endpoints

Input: intervals = []
Output: []

Input: intervals = [[1,2]]
Output: [[1,2]]

Input: intervals = [[1,4],[0,0]]
Output: [[0,0],[1,4]]

Why This Problem?
* Teaches interval manipulation (common in scheduling, calendars, resource allocation)
* Demonstrates greedy approach after sorting
* Models real-world scenarios (meeting rooms, task planning, flight schedules)
* Frequent in technical interviews (Google, Amazon, Microsoft)
* Builds intuition for sweep-line algorithms

Expected Solution Approach:
1. Sort intervals by starti (enables single-pass merge)
2. Initialize result with first interval
3. Iterate through remaining intervals:
 * If current interval overlaps with last in result → merge them
 * Else → add current interval to result
4. Overlap condition: current.start ≤ last.end
5. Merge rule: Update last.end = max(last.end, current.end)
6. Return merged result

Algorithm Steps:
* Step 1: Sort by start time → O(n log n)
* Step 2: Single pass merge → O(n)
* Total: O(n log n) time, O(1) extra space (excluding output)

Constraints:
* Must sort first to guarantee correctness
* Must handle empty input gracefully
* Output must be sorted by start time
* No need to minimize number of intervals (greedy merge ensures optimality)

Edge Cases to Handle:
* Empty input
* Single interval
* All intervals overlap
* No intervals overlap
* Intervals with zero length (e.g., [5,5])
* Touching intervals (e.g., [1,4] and [4,5])