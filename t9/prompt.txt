Use Python to solve this problem.

Problem: Dijkstra with Path Restoration

Description:
Given a weighted directed graph, find the shortest path from node S to all other nodes using Dijkstra's algorithm.
Restore and print the shortest path from S to T.

Detailed Explanation:
- Dijkstra's algorithm finds the shortest path from a source node to all other nodes in a graph with non-negative weights
- The algorithm works by greedily selecting the node with the smallest known distance and relaxing its neighbors
- Path restoration is done by storing predecessor information during the search
- If no path exists from S to T, the algorithm should detect this

Input:
- First line: N M (number of nodes, number of edges)
- Second line: S T (source node, target node)
- Next M lines: u v w (directed edge from node u to node v with weight w)

Output:
- Print shortest distance from S to T
- Print shortest path from S to T as node sequence separated by "→"
- Print "No path" if unreachable

Constraints:
- 1 ≤ N ≤ 100000
- 0 ≤ M ≤ 200000
- 0 ≤ weights ≤ 10^9
- Nodes are 0-indexed
- Graph may contain multiple edges and self-loops

Examples:

Example 1:
Input:
5 7
0 4
0 1 4
0 2 1
1 3 1
2 1 2
2 3 5
3 4 3
2 4 10

Output:
Shortest distance: 7
Shortest path: 0 → 2 → 1 → 3 → 4

Explanation:
The shortest path from node 0 to node 4 has total weight 7:
0→2 (weight 1) + 2→1 (weight 2) + 1→3 (weight 1) + 3→4 (weight 3) = 7
Alternative path 0→2→4 has weight 11, which is longer.

Example 2:
Input:
3 2
0 2
0 1 5
1 2 3

Output:
Shortest distance: 8
Shortest path: 0 → 1 → 2

Explanation:
The path 0→1→2 has total weight 5 + 3 = 8.
There is no direct edge from 0 to 2.

Example 3:
Input:
4 3
0 3
0 1 2
1 2 1
0 2 4

Output:
No path

Explanation:
There is no path from node 0 to node 3.
Nodes 0, 1, 2 are connected, but node 3 is unreachable from node 0.

Algorithm Requirements:
- Implement Dijkstra with priority queue (min-heap) for O((V+E) log V) complexity
- Use distance array to store shortest known distances
- Use predecessor array to restore the path
- Handle large graphs efficiently (up to 100,000 nodes and 200,000 edges)
- Skip processing nodes that already have better paths
- Reconstruct path by backtracking from T to S using predecessor information

Key Steps:
1. Build adjacency list representation of the graph
2. Initialize distance array with infinity and predecessor array with -1
3. Use min-heap to always process the node with smallest known distance
4. For each node, relax all its neighbors
5. If a shorter path is found, update distance and predecessor
6. After algorithm completes, check if T is reachable
7. If reachable, reconstruct path by following predecessors from T back to S