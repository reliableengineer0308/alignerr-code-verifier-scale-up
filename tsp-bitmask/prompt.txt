Use Python to solve this problem.

Problem: Traveling Salesman Problem (TSP) with Bitmask DP

Description:
Given a complete undirected graph with N cities, find the minimum cost to visit all cities exactly once and return to the starting city. 
This is the classic Traveling Salesman Problem (TSP). Implement a solution using dynamic programming with bitmask.

Input Format:
- First line: T (number of test cases, 1 ≤ T ≤ 10)
- For each test case:
  - First line: N (number of cities, 2 ≤ N ≤ 20)
  - Next N lines: Each line contains N integers representing the distance matrix
    - dist[i][j] = distance from city i to city j (symmetric: dist[i][j] = dist[j][i])
    - dist[i][i] = 0
    - All distances are positive integers (1 ≤ dist ≤ 1000)

Output Format:
- For each test case, output the minimum cost to visit all cities and return to start

Constraints:
- The graph is complete and undirected
- The solution must use DP with bitmask technique
- Time complexity should be O(N² × 2^N)

Example 1 (4 Cities):
Input:
1
4
0 10 15 20
10 0 35 25
15 35 0 30
20 25 30 0

Output:
80

Explanation:
The optimal path is: 0 → 1 → 3 → 2 → 0
Cost: 10 + 25 + 30 + 15 = 80

Example 2 (3 Cities):
Input:
1
3
0 5 2
5 0 3
2 3 0

Output:
10

Explanation:
Path: 0 → 2 → 1 → 0
Cost: 2 + 3 + 5 = 10

Example 3 (5 Cities):
Input:
1
5
0 14 4 10 20
14 0 7 8 7
4 7 0 7 16
10 8 7 0 17
20 7 16 17 0

Output:
45

Explanation:
One possible optimal path: 0 → 2 → 1 → 4 → 3 → 0
Cost: 4 + 7 + 7 + 17 + 10 = 45

Example 4 (Multiple Test Cases):
Input:
2
3
0 1 2
1 0 3
2 3 0
4
0 2 9 10
2 0 6 4
9 6 0 8
10 4 8 0

Output:
6
16

Explanation:
First test case (3 cities): Path 0→1→2→0 = 1+3+2 = 6
Second test case (4 cities): Path 0→1→3→2→0 = 2+4+8+9 = 23? Wait, output is 16.
Let me check: 0→1→3→2→0 = 2+4+8+9=23, but optimal is 0→1→3→2→0? No.
Actually: 0→1→3→2→0 = 2+4+8+9=23, but maybe 0→3→1→2→0 = 10+4+6+9=29
The correct path for 16: 0→1→2→3→0 = 2+6+8+10=26? Still not 16.
Wait, let me recalculate the matrix.

Actually for the second test case:
Optimal path: 0→1→3→2→0? Let's compute properly.

The correct output 16 corresponds to path: 0→1→3→2→0 = 2+4+8+9=23? That's not 16.
There must be a different matrix. Let me provide correct example.

Corrected Example 4:
Input:
2
3
0 1 2
1 0 3
2 3 0
4
0 2 1 3
2 0 4 5
1 4 0 6
3 5 6 0

Output:
6
10

Explanation:
First case: 0→1→2→0 = 1+3+2=6
Second case: 0→2→1→3→0 = 1+4+5+3=13? Wait, not 10.
Better path: 0→2→3→1→0 = 1+6+5+2=14? Still not.
Actually: 0→1→2→3→0 = 2+4+6+3=15
The correct path for 10: 0→2→1→3→0? Let me check the matrix again.

Let's use a verified example:
Input:
2
3
0 1 2
1 0 3
2 3 0
4
0 5 2 3
5 0 4 6
2 4 0 1
3 6 1 0

Output:
6
10

Explanation:
First case: 0→1→2→0 = 1+3+2=6
Second case: 0→2→3→1→0 = 2+1+6+5=14? Not 10.
Wait, the correct path for 10: 0→2→3→1→0? No.
Actually: 0→3→2→1→0 = 3+1+4+5=13
The correct output 10 corresponds to: 0→2→3→1→0? Let me recalculate.

I think there's an error in the example. Let me use a correct one:

Verified Example 4:
Input:
2
3
0 1 2
1 0 3
2 3 0
4
0 2 9 10
2 0 6 4
9 6 0 8
10 4 8 0

Output:
6
16

The correct path for 16: 0→1→3→2→0 = 2+4+8+9=23? That's not 16.
Wait, I see the issue. Let me provide a correct working example.

Correct Working Example 4:
Input:
2
3
0 1 2
1 0 3
2 3 0
4
0 10 15 20
10 0 35 25
15 35 0 30
20 25 30 0

Output:
6
80

This matches our first example.

Algorithm Requirements:
- Use dynamic programming with bitmask
- dp[mask][i] = minimum cost to visit all cities in mask ending at city i
- Start from city 0 (you can choose any starting point, but typically 0 is used)
- Handle the case where N is up to 20 efficiently
- The solution should return to the starting city

Important Notes:
- The graph is symmetric and complete
- Use bitmask to represent visited cities (bit i set = city i visited)
- Initialize dp[1 << i][i] = dist[0][i] for the starting point
- The final answer is min over all i: dp[(1<<N)-1][i] + dist[i][0]
- Be careful with indexing (0-based)