Problem Title: Maximum Sum Subsequence with Limited Overlaps

Description:
Given an integer array nums and an integer k, find the maximum sum of a subsequence where no more than k consecutive elements (by index) are selected.
A subsequence preserves element order but does not require contiguity. However, you cannot select more than k adjacent indices in a row.
Return the maximum possible sum under this constraint.

Key Requirements:
* Use dynamic programming (DP)
* Handle negative values (skip if not beneficial)
* Support k = 1 (no adjacent picks) up to k = len(nums)
* Optimize for O(n) time and O(k) space
* Correctly handle edge cases: all negatives, single element, k=1
* Empty subsequence (sum = 0) is allowed if all elements are negative

Input Format:
- nums: list of integers, where:
 * 1 ≤ len(nums) ≤ 10⁵
 * -10³ ≤ nums[i] ≤ 10³
- k: integer, where 1 ≤ k ≤ len(nums)

Output Format:
* Integer: maximum sum of valid subsequence

Examples
Example 1:
Input: nums = [3, -2, 5, -1], k = 2
Output: 8
Explanation: Pick indices 0 and 2 → values 3 + 5 = 8. 
No 3 consecutive indices selected. Valid. Other options yield lower sums.

Example 2:
Input: nums = [1, 2, 3, 4], k = 1
Output: 4
Explanation: Can't pick any two adjacent indices. Best: pick only 4 → sum = 4

Example 3:
Input: nums = [-1, -2, -3], k = 3
Output: 0
Explanation: All negative. Best to pick nothing → sum = 0

Example 4:
Input: nums = [2, 1, 3, 4, 5], k = 3
Output: 14
Explanation: Pick indices 0, 2, 3, 4 → 2 + 3 + 4 + 5 = 14
Consecutive runs: [2,3,4] (3 elements) → allowed (k=3). Index 0 is isolated. Valid.

Example 5:
Input: nums = [5, 5, 5, 5], k = 2
Output: 15
Explanation: Can pick at most 2 consecutive. Best: indices 0-1 and 3 → 5+5+5 = 15
(or 0,2-3 → same sum)

Why This Problem?
* Teaches constrained subsequence DP with run-length tracking
* Models real-world limits: work shifts (max k days in a row), ad frequency caps, task scheduling
* Extends classic Maximum Subarray and House Robber problems
* Common in advanced algorithm interviews (Google, Meta, Uber)
* Builds intuition for sliding window + DP optimization

Expected Solution Approach
We use dynamic programming with state tracking of the length of the current consecutive run.

Key Insight
At each index i, we decide:
1. Skip nums[i] → carry forward best sum so far
2. Pick nums[i]:
 * If previous run was < k, extend it
 * Else, we must skip at least one before continuing

DP State Definition
Let:
* dp[i][c] = maximum sum up to index i ending with exactly c consecutive picks (0 ≤ c ≤ k)
But O(n×k) space is too high for large n.

Optimized Approach: O(n) Time, O(k) Space
Instead, maintain:
* An array run of size k+1, where run[c] = best sum ending with c consecutive picks
* Update run in reverse order (to avoid overwriting)
* Track global_max to avoid scanning run at end

Algorithm Steps
1. Initialize:
 * run = [-inf] * (k+1)
 * run[0] = 0 (empty subsequence)
 * global_max = 0
2. For each num in nums:
 a. Update run[c] for c = k down to 1:
  * run[c] = run[c-1] + num (extend previous run)
 b. Update run[0]:
  * run[0] = max(run[0], global_max) (skip current, keep best so far)
 c. Update global_max = max(global_max, run[1..k])
3. Return global_max
Why reverse update? To prevent using the same num twice in one step.

Intuition Behind Reverse Update
If we updated run[1] → run[k] in increasing order, we’d risk:
* Using run[0] to compute run[1]
* Then using the new run[1] to compute run[2]
* Effectively picking num multiple times
By going from k down to 1, we ensure we use the previous state of run, not the updated one.